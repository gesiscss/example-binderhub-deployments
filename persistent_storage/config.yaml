nodeSelector:
  base: worker

config:
  BinderHub:
    base_url: /services/binder/

extraEnv:
  - name: PROJECTS_LIMIT_PER_USER
    value: "3"

extraConfig:
  00-launcher:  |
    from tornado import web
    import json
    import os

    async def check_user_projects(launcher, image, username, server_name, repo_url):
        # we are making request to API with admin token
        resp = await launcher.api_request(
            'projects/%s' % username,
            method='GET',
        )
        body = json.loads(resp.body.decode('utf-8'))
        projects = body['projects']
        projects_limit = int(os.getenv('PROJECTS_LIMIT_PER_USER', 0))
        if projects_limit > 0 and projects:
          projects_repo_list = [p[0] for p in projects]
          if repo_url not in projects_repo_list and len(projects) >= projects_limit:
              raise web.HTTPError(409, "No more than {} projects is allowed. "
                                       "One must be deleted before a new project can be created.".format(projects_limit))
    c.Launcher.pre_launch_hook = check_user_projects

jupyterhub:
  hub:
    templateVars:
      projects_limit: "3"
      announcement_home: "User has to go to <a href='https://notebooks-test.gesis.org/services/binder/' target='_blank'>https://notebooks-test.gesis.org/services/binder/</a> and confirm that Binder service can identify the user with user's JupyterHub account (A service is attempting to authorize with your JupyterHub account). Otherwise nothing works in this page."
    # clone custom JupyterHub templates (jhub home with binder form) into a volume
    initContainers:
      - name: git-clone-templates
        image: alpine/git
        args:
          - clone
          - --single-branch
          - --branch=master
          - --depth=1
          - --
          - https://github.com/gesiscss/example-binderhub-deployments.git
          - /etc/jupyterhub/custom
        securityContext:
          runAsUser: 0
        volumeMounts:
          - name: custom-templates
            mountPath: /etc/jupyterhub/custom
    extraVolumes:
      - name: custom-templates
        emptyDir: {}
    extraVolumeMounts:
      - name: custom-templates
        mountPath: /etc/jupyterhub/custom

    services:
      binder:
        url: http://194.95.75.9:30193  # base worker
        oauth_redirect_uri: "https://notebooks-test.gesis.org/services/binder/oauth_callback"
    templatePaths:
      - "/etc/jupyterhub/custom/persistent_storage/jupyterhub/templates"
    extraConfig:
      # set pod restart_policy back to default value OnFailure
      neverRestart: |
        c.KubeSpawner.extra_pod_config.update({'restart_policy': 'OnFailure'})
      binder: |
        from tornado import web
        from kubespawner import KubeSpawner
        from os.path import join

        class BinderSpawner(KubeSpawner):

          default_project = ['https://github.com/gesiscss/data_science_image', 'gesiscss/singleuser-orc:r2d-dd93b3e', 'master']

          def strip_repo_url(self, repo_url):
              p = "http://"
              if repo_url.startswith(p):
                  repo_url = repo_url[len(p):]
              p = "https://"
              if repo_url.startswith(p):
                  repo_url = repo_url[len(p):]
              p = ".git"
              if repo_url.endswith(p):
                  repo_url = repo_url[:-len(p)]
              return repo_url.rstrip('/')

          def url_to_dir(self, url):
            url = self.strip_repo_url(url)
            return '_'.join(reversed(url.split('/')[-2:]))

          def start(self):
            # clean attributes, so we dont save wrong values in state when error happens
            for attr in ('repo_url', 'ref', 'image'):
                self.__dict__.pop(attr, None)

            # get last saved projects
            projects = self.orm_spawner.state['projects']
            # get list of projects to delete from disk before spawn in initContainer
            deleted_projects = self.orm_spawner.state['deleted_projects']

            # get image spec from user_options
            if 'image' in self.user_options and \
              'repo_url' in self.user_options and \
              'token' in self.user_options:
              # binder service sets the image spec via user options
              # NOTE: user can pass any options through API (without using binder) too
              self.image = self.user_options['image']
              self.ref = self.image.split(':')[-1]
              self.repo_url = self.user_options['repo_url']  # repo_url is generated in bhub by repo providers
            else:
              if projects:
                # user starts server without binder form (default)
                # for example via spawn url or by refresing user page when server was stopped
                # launch last repo in projects
                self.repo_url, self.image, self.ref, _ = projects[-1]
              else:
                # if user has no projects (e.g. user makes first login, deletes default project and uses spawn url), start default repo
                self.repo_url, self.image, self.ref = self.default_project

            # prepare initContainer
            # NOTE: first initContainer runs and when it is done, then notebook container runs
            # https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container
            # https://github.com/jupyterhub/kubespawner/blob/v0.8.1/kubespawner/spawner.py#L638-L664
            mount_path = '/projects/'
            # first it deletes projects on disk (if there are any to delete)
            delete_cmd = f"rm -rf {' '.join([join(mount_path, self.url_to_dir(d)) for d in deleted_projects])}" if deleted_projects else ""
            # then copies image's home folder (repo content after r2d process) into project's dir on disk (if project_path doesnt exists on persistent disk)
            project_dir = self.url_to_dir(self.repo_url)
            project_path = join(mount_path, project_dir)
            copy_cmd = f"if [ -d {project_path} ]; " \
                       f"then echo 'directory {project_path} exists'; " \
                       f"elif [ -L {project_path} ]; " \
                       f"then echo '{project_path} is a symlink'; " \
                       f"else mkdir {project_path} && cp -a ~/. {project_path}; fi"
            init_container_cmds = [delete_cmd, copy_cmd] if delete_cmd else [copy_cmd]
            projects_volume_mount = {'name': self.volumes[0]['name'], 'mountPath': mount_path}
            self.init_containers = [{
                "name": "project-manager",
                "image": self.image,
                "command": ["/bin/sh", "-c", " && ".join(init_container_cmds)],
                # volumes is already defined for notebook container (self.volumes)
                "volume_mounts": [projects_volume_mount],
            }]

            # https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath
            self.volume_mounts.append(projects_volume_mount)
            # mountPath is /home/jovyan, this is set in z2jh helm chart values.yaml
            #mount_path = "~/"
            #mount_path = "$(HOME)"
            #self.volume_mounts[0]['mountPath'] = mount_path
            # mount only project_path to home
            self.volume_mounts[0]['subPath'] = project_dir

            self.reset_deleted_projects = True
            return super().start()

          def get_state_field(self, name):
            # just get current value of a field in state, don't update thing in state
            self.update_projects = False
            reset_deleted_projects = getattr(self, 'reset_deleted_projects', False)
            self.reset_deleted_projects = False
            state = self.get_state()
            self.update_projects = True
            self.reset_deleted_projects = reset_deleted_projects
            return state[name]

          def get_state(self):
            """Use this method to update projects, because this method is called both in
            start and stop of the server (see jupyterhub.User's `start` and `stop` methods),
            db.commit is called after these methods.
            """
            # default_projects is only to use when first login
            default_projects = [self.default_project + ['never']]
            _state = self.orm_spawner.state
            projects = _state.get('projects', []) if _state else default_projects
            deleted_projects = _state.get('deleted_projects', []) if _state else []

            state = super().get_state()
            state['projects'] = projects
            state['deleted_projects'] = deleted_projects

            if getattr(self, 'update_projects', True) is True and hasattr(self, 'repo_url') and hasattr(self, 'image') and hasattr(self, 'ref'):
              # project is started or already running or is stopped,
              # so move project to the end and update the last launched time (last seen)
              from datetime import datetime
              e = [self.repo_url, self.image, self.ref, datetime.utcnow().isoformat() + 'Z']
              new_projects = []
              for p in projects:
                if p[0] != e[0]:
                  new_projects.append(p)
              new_projects.append(e)
              state['projects'] = new_projects

            if getattr(self, 'reset_deleted_projects', False) is True:
              state['deleted_projects'] = []

            return state
        c.JupyterHub.spawner_class = BinderSpawner
      projects_handler: |
        import json
        from tornado.escape import json_decode
        from tornado import web

        from jupyterhub.utils import admin_only
        from jupyterhub.apihandlers.base import APIHandler
        from jupyterhub.apihandlers.users import admin_or_self

        class ProjectAPIHandler(APIHandler):
            @admin_only
            async def get(self, name):
                # get user's projects
                user = self.find_user(name)
                if not user:
                  raise web.HTTPError(404)
                projects = {'projects': user.spawner.get_state_field('projects')}
                self.write(json.dumps(projects))

            @admin_or_self
            async def delete(self, name):
                # delete a project of user
                user = self.find_user(name)
                response = {}
                if user.running:
                    response["error"] = "Project deletion is not allowed while user server is running."
                else:
                    body = json_decode(self.request.body)
                    if "repo_url" in body and "name" in body and "id" in body:
                        repo_url = body["repo_url"]
                        delete_on_disk = body.get("delete_on_disk", False)
                        projects = user.spawner.get_state_field('projects')
                        new_projects = []
                        deleted_projects = user.spawner.get_state_field('deleted_projects')
                        found = False
                        for project in projects:
                            if repo_url != project[0]:
                                new_projects.append(project)
                            else:
                                found = True
                                if delete_on_disk is True and repo_url not in deleted_projects:
                                    deleted_projects.append(repo_url)
                        if found is True:
                            # NOTE: this way we ensure that this JSONDict field (state) is updated with db.commit()
                            state = user.spawner.get_state()
                            state["projects"] = new_projects
                            state["deleted_projects"] = deleted_projects
                            user.spawner.orm_spawner.state = state
                            self.db.commit()

                            response["success"] = f"Project {body['name']} is deleted."
                            response["id"] = body["id"]
                        else:
                            response["error"] = f"Project {body['name']} ({body['repo_url']}) doesn't exist."
                    else:
                        response["error"] = "Bad request."
                self.write(json.dumps(response))

        c.JupyterHub.extra_handlers = [(r'/api/projects/([^/]+)', ProjectAPIHandler), ]

  singleuser:
    events: true
    storage:
      type: dynamic
      capacity: 5Gi
    image:
      # https://github.com/gesiscss/data_science_image
      # NOTE: when you update this image, don't forget to update `default_project` attribute of `BinderSpawner`
      name: gesiscss/singleuser-orc
      tag: "r2d-dd93b3e"
